- 逻辑结构
    - 集合结构
    - 线性结构
    - 树形结构
    - 图形结构
- 物理结构(存储结构)
    - 顺序存储结构：

        是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。

        如数组，但是对于经常变化修改的数据，不适合使用数组存储

    - 链式存储结构

        是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个**指针**存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。
- 数据类型

    是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

    C语言中，按照取值的不同，数据类型可以分为两类：

    原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。

    结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。



- 算法

    算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

- 算法的特性：
    - 输入
    - 输出
    - 有穷性
    - 确定性
    - 可行性

    算法设计的要求：正确性，可读性，健壮性，高效率，低存储量

- 算法效率的度量方法

    - 渐进增长： 输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐近增长的。即，给定一个两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是大于g(n)，那么f(n)的增长渐进快于g(n)。同使，随着n的增大，后面的常数项是不影响最终的算法变化的，所以可以忽略这些假发常数。甚至可以忽略掉与最高次项相乘的常数。**综上，判断算法效率时，只需要关注最高阶项的阶数即可**

    - 算法时间复杂度：

        语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度也是就是算法的时间量度，记作：T(n)=O(f(n))，表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。

        - 推导大O阶方法

            1. 用常数1取代运行时间中的所有加法常数
            2. 在修改后的运行次数函数中，只保留最高阶项
            3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数
        
        - 常数阶

            无论常数是多少，都记作O(1)。对于分支结构而言，无论真假，执行的次数是恒定的，不会随着n的变化而发生变化，因此时间复杂度也是O(1)。

        - 线性阶

            关键在于分析循环结构的运行情况。记为O(n)

        - 对数阶

            ```C
            int count = 1;
            while(count < n)
            {
                count = count * 2
            }
            ```
            由于每次count乘2之后，就距离n更近了一步。因此，2^x=n，求出x=log2n。所以这个循环的时间复杂度为O(logn)
        
        - 平方阶

            嵌套循环
            ```C
            int i, j;
            for(i = 0; i < n; i++)
            {
                for(j = i; j < n; j++)
                {}
            }
            ```
            需要循环次数n + (n-1) + (n-2) + ... + 2 + 1 = (n + 1) * n / 2。
            用推导大O阶的方法，没有加法常数不予考虑 -> 只保留最高阶项n ^ 2 / 2 -> 去除这个项相乘的常数1/2，最终这段代码时间复杂度为O(n^2)

        - 常用的时间复杂度耗时大小：
        
            O(1)<O(logn)<O(n)<O(nlogn)<O(n2)<O(n3)<O(2n)<O(n!)<O(nn)